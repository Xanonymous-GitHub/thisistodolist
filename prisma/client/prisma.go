// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Session(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"session",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

type SessionsParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Sessions(params *SessionsParams) *SessionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessions",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExecArray{ret}
}

type SessionsConnectionParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *SessionConnection) Nodes() []Session {
	var nodes []Session
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *SessionConnection) NodesPtr() []*Session {
	var nodes []*Session
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) SessionsConnection(params *SessionsConnectionParams) *SessionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessionsConnection",
		[]string{"edges", "pageInfo"})

	return &SessionConnectionExec{ret}
}

func (client *Client) Todo(params TodoWhereUniqueInput) *TodoExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TodoWhereUniqueInput!", "Todo"},
		"todo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

type TodoesParams struct {
	Where   *TodoWhereInput   `json:"where,omitempty"`
	OrderBy *TodoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Todoes(params *TodoesParams) *TodoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TodoWhereInput", "TodoOrderByInput", "Todo"},
		"todoes",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExecArray{ret}
}

type TodoesConnectionParams struct {
	Where   *TodoWhereInput   `json:"where,omitempty"`
	OrderBy *TodoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *TodoConnection) Nodes() []Todo {
	var nodes []Todo
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *TodoConnection) NodesPtr() []*Todo {
	var nodes []*Todo
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) TodoesConnection(params *TodoesConnectionParams) *TodoConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TodoWhereInput", "TodoOrderByInput", "Todo"},
		"todoesConnection",
		[]string{"edges", "pageInfo"})

	return &TodoConnectionExec{ret}
}

func (client *Client) TodoSort(params TodoSortWhereUniqueInput) *TodoSortExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TodoSortWhereUniqueInput!", "TodoSort"},
		"todoSort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

type TodoSortsParams struct {
	Where   *TodoSortWhereInput   `json:"where,omitempty"`
	OrderBy *TodoSortOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) TodoSorts(params *TodoSortsParams) *TodoSortExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TodoSortWhereInput", "TodoSortOrderByInput", "TodoSort"},
		"todoSorts",
		[]string{"sortID", "userful"})

	return &TodoSortExecArray{ret}
}

type TodoSortsConnectionParams struct {
	Where   *TodoSortWhereInput   `json:"where,omitempty"`
	OrderBy *TodoSortOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *TodoSortConnection) Nodes() []TodoSort {
	var nodes []TodoSort
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *TodoSortConnection) NodesPtr() []*TodoSort {
	var nodes []*TodoSort
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) TodoSortsConnection(params *TodoSortsConnectionParams) *TodoSortConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TodoSortWhereInput", "TodoSortOrderByInput", "TodoSort"},
		"todoSortsConnection",
		[]string{"edges", "pageInfo"})

	return &TodoSortConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) EmailToken(params EmailTokenWhereUniqueInput) *EmailTokenExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"emailTokenWhereUniqueInput!", "emailToken"},
		"emailToken",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

type EmailTokensParams struct {
	Where   *EmailTokenWhereInput   `json:"where,omitempty"`
	OrderBy *EmailTokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) EmailTokens(params *EmailTokensParams) *EmailTokenExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"emailTokenWhereInput", "emailTokenOrderByInput", "emailToken"},
		"emailTokens",
		[]string{"id", "email", "token"})

	return &EmailTokenExecArray{ret}
}

type EmailTokensConnectionParams struct {
	Where   *EmailTokenWhereInput   `json:"where,omitempty"`
	OrderBy *EmailTokenOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *EmailTokenConnection) Nodes() []EmailToken {
	var nodes []EmailToken
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *EmailTokenConnection) NodesPtr() []*EmailToken {
	var nodes []*EmailToken
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) EmailTokensConnection(params *EmailTokensConnectionParams) *EmailTokenConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailTokenWhereInput", "EmailTokenOrderByInput", "EmailToken"},
		"emailTokensConnection",
		[]string{"edges", "pageInfo"})

	return &EmailTokenConnectionExec{ret}
}

func (client *Client) CreateSession(params SessionCreateInput) *SessionExec {
	ret := client.Client.Create(
		params,
		[2]string{"SessionCreateInput!", "Session"},
		"createSession",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

type SessionUpdateParams struct {
	Data  SessionUpdateInput      `json:"data"`
	Where SessionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSession(params SessionUpdateParams) *SessionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SessionUpdateInput!", "SessionWhereUniqueInput!", "Session"},
		"updateSession",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

type SessionUpdateManyParams struct {
	Data  SessionUpdateManyMutationInput `json:"data"`
	Where *SessionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManySessions(params SessionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"SessionUpdateManyMutationInput!", "SessionWhereInput"},
		"updateManySessions")
	return &BatchPayloadExec{exec}
}

type SessionUpsertParams struct {
	Where  SessionWhereUniqueInput `json:"where"`
	Create SessionCreateInput      `json:"create"`
	Update SessionUpdateInput      `json:"update"`
}

func (client *Client) UpsertSession(params SessionUpsertParams) *SessionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SessionWhereUniqueInput!", "SessionCreateInput!", "SessionUpdateInput!", "Session"},
		"upsertSession",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteSession(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"deleteSession",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteManySessions(params *SessionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SessionWhereInput", "deleteManySessions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTodo(params TodoCreateInput) *TodoExec {
	ret := client.Client.Create(
		params,
		[2]string{"TodoCreateInput!", "Todo"},
		"createTodo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

type TodoUpdateParams struct {
	Data  TodoUpdateInput      `json:"data"`
	Where TodoWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTodo(params TodoUpdateParams) *TodoExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TodoUpdateInput!", "TodoWhereUniqueInput!", "Todo"},
		"updateTodo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

type TodoUpdateManyParams struct {
	Data  TodoUpdateManyMutationInput `json:"data"`
	Where *TodoWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTodoes(params TodoUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TodoUpdateManyMutationInput!", "TodoWhereInput"},
		"updateManyTodoes")
	return &BatchPayloadExec{exec}
}

type TodoUpsertParams struct {
	Where  TodoWhereUniqueInput `json:"where"`
	Create TodoCreateInput      `json:"create"`
	Update TodoUpdateInput      `json:"update"`
}

func (client *Client) UpsertTodo(params TodoUpsertParams) *TodoExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TodoWhereUniqueInput!", "TodoCreateInput!", "TodoUpdateInput!", "Todo"},
		"upsertTodo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

func (client *Client) DeleteTodo(params TodoWhereUniqueInput) *TodoExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TodoWhereUniqueInput!", "Todo"},
		"deleteTodo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

func (client *Client) DeleteManyTodoes(params *TodoWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TodoWhereInput", "deleteManyTodoes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTodoSort(params TodoSortCreateInput) *TodoSortExec {
	ret := client.Client.Create(
		params,
		[2]string{"TodoSortCreateInput!", "TodoSort"},
		"createTodoSort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

type TodoSortUpdateParams struct {
	Data  TodoSortUpdateInput      `json:"data"`
	Where TodoSortWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTodoSort(params TodoSortUpdateParams) *TodoSortExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TodoSortUpdateInput!", "TodoSortWhereUniqueInput!", "TodoSort"},
		"updateTodoSort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

type TodoSortUpdateManyParams struct {
	Data  TodoSortUpdateManyMutationInput `json:"data"`
	Where *TodoSortWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTodoSorts(params TodoSortUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TodoSortUpdateManyMutationInput!", "TodoSortWhereInput"},
		"updateManyTodoSorts")
	return &BatchPayloadExec{exec}
}

type TodoSortUpsertParams struct {
	Where  TodoSortWhereUniqueInput `json:"where"`
	Create TodoSortCreateInput      `json:"create"`
	Update TodoSortUpdateInput      `json:"update"`
}

func (client *Client) UpsertTodoSort(params TodoSortUpsertParams) *TodoSortExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TodoSortWhereUniqueInput!", "TodoSortCreateInput!", "TodoSortUpdateInput!", "TodoSort"},
		"upsertTodoSort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

func (client *Client) DeleteTodoSort(params TodoSortWhereUniqueInput) *TodoSortExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TodoSortWhereUniqueInput!", "TodoSort"},
		"deleteTodoSort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

func (client *Client) DeleteManyTodoSorts(params *TodoSortWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TodoSortWhereInput", "deleteManyTodoSorts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateemailToken(params EmailTokenCreateInput) *EmailTokenExec {
	ret := client.Client.Create(
		params,
		[2]string{"emailTokenCreateInput!", "emailToken"},
		"createemailToken",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

type EmailTokenUpdateParams struct {
	Data  EmailTokenUpdateInput      `json:"data"`
	Where EmailTokenWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateemailToken(params EmailTokenUpdateParams) *EmailTokenExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"emailTokenUpdateInput!", "emailTokenWhereUniqueInput!", "emailToken"},
		"updateemailToken",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

type EmailTokenUpdateManyParams struct {
	Data  EmailTokenUpdateManyMutationInput `json:"data"`
	Where *EmailTokenWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyemailTokens(params EmailTokenUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"emailTokenUpdateManyMutationInput!", "emailTokenWhereInput"},
		"updateManyemailTokens")
	return &BatchPayloadExec{exec}
}

type EmailTokenUpsertParams struct {
	Where  EmailTokenWhereUniqueInput `json:"where"`
	Create EmailTokenCreateInput      `json:"create"`
	Update EmailTokenUpdateInput      `json:"update"`
}

func (client *Client) UpsertemailToken(params EmailTokenUpsertParams) *EmailTokenExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"emailTokenWhereUniqueInput!", "emailTokenCreateInput!", "emailTokenUpdateInput!", "emailToken"},
		"upsertemailToken",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

func (client *Client) DeleteemailToken(params EmailTokenWhereUniqueInput) *EmailTokenExec {
	ret := client.Client.Delete(
		params,
		[2]string{"emailTokenWhereUniqueInput!", "emailToken"},
		"deleteemailToken",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

func (client *Client) DeleteManyemailTokens(params *EmailTokenWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "emailTokenWhereInput", "deleteManyemailTokens")
	return &BatchPayloadExec{exec}
}

type SessionOrderByInput string

const (
	SessionOrderByInputIDAsc         SessionOrderByInput = "id_ASC"
	SessionOrderByInputIDDesc        SessionOrderByInput = "id_DESC"
	SessionOrderByInputUsernameAsc   SessionOrderByInput = "username_ASC"
	SessionOrderByInputUsernameDesc  SessionOrderByInput = "username_DESC"
	SessionOrderByInputTokenAsc      SessionOrderByInput = "token_ASC"
	SessionOrderByInputTokenDesc     SessionOrderByInput = "token_DESC"
	SessionOrderByInputUpdatedAtAsc  SessionOrderByInput = "updatedAt_ASC"
	SessionOrderByInputUpdatedAtDesc SessionOrderByInput = "updatedAt_DESC"
)

type Level string

const (
	LevelAdmin      Level = "ADMIN"
	LevelUser       Level = "USER"
	LevelRestricted Level = "RESTRICTED"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc             UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc            UserOrderByInput = "id_DESC"
	UserOrderByInputUsernameAsc       UserOrderByInput = "username_ASC"
	UserOrderByInputUsernameDesc      UserOrderByInput = "username_DESC"
	UserOrderByInputEmailVerifiedAsc  UserOrderByInput = "emailVerified_ASC"
	UserOrderByInputEmailVerifiedDesc UserOrderByInput = "emailVerified_DESC"
	UserOrderByInputEmailAsc          UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc         UserOrderByInput = "email_DESC"
	UserOrderByInputNicknameAsc       UserOrderByInput = "nickname_ASC"
	UserOrderByInputNicknameDesc      UserOrderByInput = "nickname_DESC"
	UserOrderByInputPictureUrlAsc     UserOrderByInput = "pictureUrl_ASC"
	UserOrderByInputPictureUrlDesc    UserOrderByInput = "pictureUrl_DESC"
	UserOrderByInputVerifiedAsc       UserOrderByInput = "verified_ASC"
	UserOrderByInputVerifiedDesc      UserOrderByInput = "verified_DESC"
	UserOrderByInputUserLevelAsc      UserOrderByInput = "userLevel_ASC"
	UserOrderByInputUserLevelDesc     UserOrderByInput = "userLevel_DESC"
	UserOrderByInputPasswordAsc       UserOrderByInput = "password_ASC"
	UserOrderByInputPasswordDesc      UserOrderByInput = "password_DESC"
)

type TodoOrderByInput string

const (
	TodoOrderByInputIDAsc         TodoOrderByInput = "id_ASC"
	TodoOrderByInputIDDesc        TodoOrderByInput = "id_DESC"
	TodoOrderByInputContentAsc    TodoOrderByInput = "content_ASC"
	TodoOrderByInputContentDesc   TodoOrderByInput = "content_DESC"
	TodoOrderByInputCompletedAsc  TodoOrderByInput = "completed_ASC"
	TodoOrderByInputCompletedDesc TodoOrderByInput = "completed_DESC"
	TodoOrderByInputDeletedAsc    TodoOrderByInput = "deleted_ASC"
	TodoOrderByInputDeletedDesc   TodoOrderByInput = "deleted_DESC"
	TodoOrderByInputPrivateAsc    TodoOrderByInput = "private_ASC"
	TodoOrderByInputPrivateDesc   TodoOrderByInput = "private_DESC"
	TodoOrderByInputLockedAsc     TodoOrderByInput = "locked_ASC"
	TodoOrderByInputLockedDesc    TodoOrderByInput = "locked_DESC"
)

type TodoSortOrderByInput string

const (
	TodoSortOrderByInputSortIdAsc   TodoSortOrderByInput = "sortID_ASC"
	TodoSortOrderByInputSortIdDesc  TodoSortOrderByInput = "sortID_DESC"
	TodoSortOrderByInputUserfulAsc  TodoSortOrderByInput = "userful_ASC"
	TodoSortOrderByInputUserfulDesc TodoSortOrderByInput = "userful_DESC"
)

type EmailTokenOrderByInput string

const (
	EmailTokenOrderByInputIDAsc     EmailTokenOrderByInput = "id_ASC"
	EmailTokenOrderByInputIDDesc    EmailTokenOrderByInput = "id_DESC"
	EmailTokenOrderByInputEmailAsc  EmailTokenOrderByInput = "email_ASC"
	EmailTokenOrderByInputEmailDesc EmailTokenOrderByInput = "email_DESC"
	EmailTokenOrderByInputTokenAsc  EmailTokenOrderByInput = "token_ASC"
	EmailTokenOrderByInputTokenDesc EmailTokenOrderByInput = "token_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type SessionWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Username *string `json:"username,omitempty"`
	Token    *string `json:"token,omitempty"`
}

type SessionWhereInput struct {
	ID                    *string             `json:"id,omitempty"`
	IDNot                 *string             `json:"id_not,omitempty"`
	IDIn                  []string            `json:"id_in,omitempty"`
	IDNotIn               []string            `json:"id_not_in,omitempty"`
	IDLt                  *string             `json:"id_lt,omitempty"`
	IDLte                 *string             `json:"id_lte,omitempty"`
	IDGt                  *string             `json:"id_gt,omitempty"`
	IDGte                 *string             `json:"id_gte,omitempty"`
	IDContains            *string             `json:"id_contains,omitempty"`
	IDNotContains         *string             `json:"id_not_contains,omitempty"`
	IDStartsWith          *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string             `json:"id_not_ends_with,omitempty"`
	Username              *string             `json:"username,omitempty"`
	UsernameNot           *string             `json:"username_not,omitempty"`
	UsernameIn            []string            `json:"username_in,omitempty"`
	UsernameNotIn         []string            `json:"username_not_in,omitempty"`
	UsernameLt            *string             `json:"username_lt,omitempty"`
	UsernameLte           *string             `json:"username_lte,omitempty"`
	UsernameGt            *string             `json:"username_gt,omitempty"`
	UsernameGte           *string             `json:"username_gte,omitempty"`
	UsernameContains      *string             `json:"username_contains,omitempty"`
	UsernameNotContains   *string             `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string             `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string             `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string             `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string             `json:"username_not_ends_with,omitempty"`
	Token                 *string             `json:"token,omitempty"`
	TokenNot              *string             `json:"token_not,omitempty"`
	TokenIn               []string            `json:"token_in,omitempty"`
	TokenNotIn            []string            `json:"token_not_in,omitempty"`
	TokenLt               *string             `json:"token_lt,omitempty"`
	TokenLte              *string             `json:"token_lte,omitempty"`
	TokenGt               *string             `json:"token_gt,omitempty"`
	TokenGte              *string             `json:"token_gte,omitempty"`
	TokenContains         *string             `json:"token_contains,omitempty"`
	TokenNotContains      *string             `json:"token_not_contains,omitempty"`
	TokenStartsWith       *string             `json:"token_starts_with,omitempty"`
	TokenNotStartsWith    *string             `json:"token_not_starts_with,omitempty"`
	TokenEndsWith         *string             `json:"token_ends_with,omitempty"`
	TokenNotEndsWith      *string             `json:"token_not_ends_with,omitempty"`
	UpdatedAt             *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string             `json:"updatedAt_gte,omitempty"`
	And                   []SessionWhereInput `json:"AND,omitempty"`
	Or                    []SessionWhereInput `json:"OR,omitempty"`
	Not                   []SessionWhereInput `json:"NOT,omitempty"`
}

type TodoWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereInput struct {
	ID                      *string          `json:"id,omitempty"`
	IDNot                   *string          `json:"id_not,omitempty"`
	IDIn                    []string         `json:"id_in,omitempty"`
	IDNotIn                 []string         `json:"id_not_in,omitempty"`
	IDLt                    *string          `json:"id_lt,omitempty"`
	IDLte                   *string          `json:"id_lte,omitempty"`
	IDGt                    *string          `json:"id_gt,omitempty"`
	IDGte                   *string          `json:"id_gte,omitempty"`
	IDContains              *string          `json:"id_contains,omitempty"`
	IDNotContains           *string          `json:"id_not_contains,omitempty"`
	IDStartsWith            *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string          `json:"id_not_ends_with,omitempty"`
	Username                *string          `json:"username,omitempty"`
	UsernameNot             *string          `json:"username_not,omitempty"`
	UsernameIn              []string         `json:"username_in,omitempty"`
	UsernameNotIn           []string         `json:"username_not_in,omitempty"`
	UsernameLt              *string          `json:"username_lt,omitempty"`
	UsernameLte             *string          `json:"username_lte,omitempty"`
	UsernameGt              *string          `json:"username_gt,omitempty"`
	UsernameGte             *string          `json:"username_gte,omitempty"`
	UsernameContains        *string          `json:"username_contains,omitempty"`
	UsernameNotContains     *string          `json:"username_not_contains,omitempty"`
	UsernameStartsWith      *string          `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith   *string          `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith        *string          `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith     *string          `json:"username_not_ends_with,omitempty"`
	EmailVerified           *bool            `json:"emailVerified,omitempty"`
	EmailVerifiedNot        *bool            `json:"emailVerified_not,omitempty"`
	Email                   *string          `json:"email,omitempty"`
	EmailNot                *string          `json:"email_not,omitempty"`
	EmailIn                 []string         `json:"email_in,omitempty"`
	EmailNotIn              []string         `json:"email_not_in,omitempty"`
	EmailLt                 *string          `json:"email_lt,omitempty"`
	EmailLte                *string          `json:"email_lte,omitempty"`
	EmailGt                 *string          `json:"email_gt,omitempty"`
	EmailGte                *string          `json:"email_gte,omitempty"`
	EmailContains           *string          `json:"email_contains,omitempty"`
	EmailNotContains        *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith         *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith      *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith           *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith        *string          `json:"email_not_ends_with,omitempty"`
	Nickname                *string          `json:"nickname,omitempty"`
	NicknameNot             *string          `json:"nickname_not,omitempty"`
	NicknameIn              []string         `json:"nickname_in,omitempty"`
	NicknameNotIn           []string         `json:"nickname_not_in,omitempty"`
	NicknameLt              *string          `json:"nickname_lt,omitempty"`
	NicknameLte             *string          `json:"nickname_lte,omitempty"`
	NicknameGt              *string          `json:"nickname_gt,omitempty"`
	NicknameGte             *string          `json:"nickname_gte,omitempty"`
	NicknameContains        *string          `json:"nickname_contains,omitempty"`
	NicknameNotContains     *string          `json:"nickname_not_contains,omitempty"`
	NicknameStartsWith      *string          `json:"nickname_starts_with,omitempty"`
	NicknameNotStartsWith   *string          `json:"nickname_not_starts_with,omitempty"`
	NicknameEndsWith        *string          `json:"nickname_ends_with,omitempty"`
	NicknameNotEndsWith     *string          `json:"nickname_not_ends_with,omitempty"`
	PictureUrl              *string          `json:"pictureUrl,omitempty"`
	PictureUrlNot           *string          `json:"pictureUrl_not,omitempty"`
	PictureUrlIn            []string         `json:"pictureUrl_in,omitempty"`
	PictureUrlNotIn         []string         `json:"pictureUrl_not_in,omitempty"`
	PictureUrlLt            *string          `json:"pictureUrl_lt,omitempty"`
	PictureUrlLte           *string          `json:"pictureUrl_lte,omitempty"`
	PictureUrlGt            *string          `json:"pictureUrl_gt,omitempty"`
	PictureUrlGte           *string          `json:"pictureUrl_gte,omitempty"`
	PictureUrlContains      *string          `json:"pictureUrl_contains,omitempty"`
	PictureUrlNotContains   *string          `json:"pictureUrl_not_contains,omitempty"`
	PictureUrlStartsWith    *string          `json:"pictureUrl_starts_with,omitempty"`
	PictureUrlNotStartsWith *string          `json:"pictureUrl_not_starts_with,omitempty"`
	PictureUrlEndsWith      *string          `json:"pictureUrl_ends_with,omitempty"`
	PictureUrlNotEndsWith   *string          `json:"pictureUrl_not_ends_with,omitempty"`
	Verified                *bool            `json:"verified,omitempty"`
	VerifiedNot             *bool            `json:"verified_not,omitempty"`
	UserLevel               *Level           `json:"userLevel,omitempty"`
	UserLevelNot            *Level           `json:"userLevel_not,omitempty"`
	UserLevelIn             []Level          `json:"userLevel_in,omitempty"`
	UserLevelNotIn          []Level          `json:"userLevel_not_in,omitempty"`
	Password                *string          `json:"password,omitempty"`
	PasswordNot             *string          `json:"password_not,omitempty"`
	PasswordIn              []string         `json:"password_in,omitempty"`
	PasswordNotIn           []string         `json:"password_not_in,omitempty"`
	PasswordLt              *string          `json:"password_lt,omitempty"`
	PasswordLte             *string          `json:"password_lte,omitempty"`
	PasswordGt              *string          `json:"password_gt,omitempty"`
	PasswordGte             *string          `json:"password_gte,omitempty"`
	PasswordContains        *string          `json:"password_contains,omitempty"`
	PasswordNotContains     *string          `json:"password_not_contains,omitempty"`
	PasswordStartsWith      *string          `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith   *string          `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith        *string          `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith     *string          `json:"password_not_ends_with,omitempty"`
	FriendsEvery            *UserWhereInput  `json:"friends_every,omitempty"`
	FriendsSome             *UserWhereInput  `json:"friends_some,omitempty"`
	FriendsNone             *UserWhereInput  `json:"friends_none,omitempty"`
	TodosEvery              *TodoWhereInput  `json:"todos_every,omitempty"`
	TodosSome               *TodoWhereInput  `json:"todos_some,omitempty"`
	TodosNone               *TodoWhereInput  `json:"todos_none,omitempty"`
	And                     []UserWhereInput `json:"AND,omitempty"`
	Or                      []UserWhereInput `json:"OR,omitempty"`
	Not                     []UserWhereInput `json:"NOT,omitempty"`
}

type TodoWhereInput struct {
	ID                   *string             `json:"id,omitempty"`
	IDNot                *string             `json:"id_not,omitempty"`
	IDIn                 []string            `json:"id_in,omitempty"`
	IDNotIn              []string            `json:"id_not_in,omitempty"`
	IDLt                 *string             `json:"id_lt,omitempty"`
	IDLte                *string             `json:"id_lte,omitempty"`
	IDGt                 *string             `json:"id_gt,omitempty"`
	IDGte                *string             `json:"id_gte,omitempty"`
	IDContains           *string             `json:"id_contains,omitempty"`
	IDNotContains        *string             `json:"id_not_contains,omitempty"`
	IDStartsWith         *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string             `json:"id_not_ends_with,omitempty"`
	Sort                 *TodoSortWhereInput `json:"sort,omitempty"`
	Content              *string             `json:"content,omitempty"`
	ContentNot           *string             `json:"content_not,omitempty"`
	ContentIn            []string            `json:"content_in,omitempty"`
	ContentNotIn         []string            `json:"content_not_in,omitempty"`
	ContentLt            *string             `json:"content_lt,omitempty"`
	ContentLte           *string             `json:"content_lte,omitempty"`
	ContentGt            *string             `json:"content_gt,omitempty"`
	ContentGte           *string             `json:"content_gte,omitempty"`
	ContentContains      *string             `json:"content_contains,omitempty"`
	ContentNotContains   *string             `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string             `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string             `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string             `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string             `json:"content_not_ends_with,omitempty"`
	Completed            *bool               `json:"completed,omitempty"`
	CompletedNot         *bool               `json:"completed_not,omitempty"`
	Deleted              *bool               `json:"deleted,omitempty"`
	DeletedNot           *bool               `json:"deleted_not,omitempty"`
	Author               *UserWhereInput     `json:"author,omitempty"`
	Private              *bool               `json:"private,omitempty"`
	PrivateNot           *bool               `json:"private_not,omitempty"`
	Locked               *bool               `json:"locked,omitempty"`
	LockedNot            *bool               `json:"locked_not,omitempty"`
	And                  []TodoWhereInput    `json:"AND,omitempty"`
	Or                   []TodoWhereInput    `json:"OR,omitempty"`
	Not                  []TodoWhereInput    `json:"NOT,omitempty"`
}

type TodoSortWhereInput struct {
	SortId      *int32               `json:"sortID,omitempty"`
	SortIdNot   *int32               `json:"sortID_not,omitempty"`
	SortIdIn    []int32              `json:"sortID_in,omitempty"`
	SortIdNotIn []int32              `json:"sortID_not_in,omitempty"`
	SortIdLt    *int32               `json:"sortID_lt,omitempty"`
	SortIdLte   *int32               `json:"sortID_lte,omitempty"`
	SortIdGt    *int32               `json:"sortID_gt,omitempty"`
	SortIdGte   *int32               `json:"sortID_gte,omitempty"`
	Todo        *TodoWhereInput      `json:"todo,omitempty"`
	Userful     *bool                `json:"userful,omitempty"`
	UserfulNot  *bool                `json:"userful_not,omitempty"`
	And         []TodoSortWhereInput `json:"AND,omitempty"`
	Or          []TodoSortWhereInput `json:"OR,omitempty"`
	Not         []TodoSortWhereInput `json:"NOT,omitempty"`
}

type TodoSortWhereUniqueInput struct {
	SortId *int32 `json:"sortID,omitempty"`
}

type UserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Username *string `json:"username,omitempty"`
	Email    *string `json:"email,omitempty"`
}

type EmailTokenWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type EmailTokenWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	Email              *string                `json:"email,omitempty"`
	EmailNot           *string                `json:"email_not,omitempty"`
	EmailIn            []string               `json:"email_in,omitempty"`
	EmailNotIn         []string               `json:"email_not_in,omitempty"`
	EmailLt            *string                `json:"email_lt,omitempty"`
	EmailLte           *string                `json:"email_lte,omitempty"`
	EmailGt            *string                `json:"email_gt,omitempty"`
	EmailGte           *string                `json:"email_gte,omitempty"`
	EmailContains      *string                `json:"email_contains,omitempty"`
	EmailNotContains   *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith    *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith      *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith   *string                `json:"email_not_ends_with,omitempty"`
	Token              *string                `json:"token,omitempty"`
	TokenNot           *string                `json:"token_not,omitempty"`
	TokenIn            []string               `json:"token_in,omitempty"`
	TokenNotIn         []string               `json:"token_not_in,omitempty"`
	TokenLt            *string                `json:"token_lt,omitempty"`
	TokenLte           *string                `json:"token_lte,omitempty"`
	TokenGt            *string                `json:"token_gt,omitempty"`
	TokenGte           *string                `json:"token_gte,omitempty"`
	TokenContains      *string                `json:"token_contains,omitempty"`
	TokenNotContains   *string                `json:"token_not_contains,omitempty"`
	TokenStartsWith    *string                `json:"token_starts_with,omitempty"`
	TokenNotStartsWith *string                `json:"token_not_starts_with,omitempty"`
	TokenEndsWith      *string                `json:"token_ends_with,omitempty"`
	TokenNotEndsWith   *string                `json:"token_not_ends_with,omitempty"`
	And                []EmailTokenWhereInput `json:"AND,omitempty"`
	Or                 []EmailTokenWhereInput `json:"OR,omitempty"`
	Not                []EmailTokenWhereInput `json:"NOT,omitempty"`
}

type SessionCreateInput struct {
	ID       *string `json:"id,omitempty"`
	Username string  `json:"username"`
	Token    string  `json:"token"`
}

type SessionUpdateInput struct {
	Username *string `json:"username,omitempty"`
	Token    *string `json:"token,omitempty"`
}

type SessionUpdateManyMutationInput struct {
	Username *string `json:"username,omitempty"`
	Token    *string `json:"token,omitempty"`
}

type TodoCreateInput struct {
	ID        *string                            `json:"id,omitempty"`
	Sort      *TodoSortCreateOneWithoutTodoInput `json:"sort,omitempty"`
	Content   string                             `json:"content"`
	Completed *bool                              `json:"completed,omitempty"`
	Deleted   *bool                              `json:"deleted,omitempty"`
	Author    UserCreateOneWithoutTodosInput     `json:"author"`
	Private   *bool                              `json:"private,omitempty"`
	Locked    *bool                              `json:"locked,omitempty"`
}

type TodoSortCreateOneWithoutTodoInput struct {
	Create  *TodoSortCreateWithoutTodoInput `json:"create,omitempty"`
	Connect *TodoSortWhereUniqueInput       `json:"connect,omitempty"`
}

type TodoSortCreateWithoutTodoInput struct {
	Userful *bool `json:"userful,omitempty"`
}

type UserCreateOneWithoutTodosInput struct {
	Create  *UserCreateWithoutTodosInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateWithoutTodosInput struct {
	ID            *string              `json:"id,omitempty"`
	Username      string               `json:"username"`
	EmailVerified *bool                `json:"emailVerified,omitempty"`
	Email         string               `json:"email"`
	Nickname      *string              `json:"nickname,omitempty"`
	PictureUrl    *string              `json:"pictureUrl,omitempty"`
	Verified      *bool                `json:"verified,omitempty"`
	UserLevel     *Level               `json:"userLevel,omitempty"`
	Password      string               `json:"password"`
	Friends       *UserCreateManyInput `json:"friends,omitempty"`
}

type UserCreateManyInput struct {
	Create  []UserCreateInput      `json:"create,omitempty"`
	Connect []UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserCreateInput struct {
	ID            *string                           `json:"id,omitempty"`
	Username      string                            `json:"username"`
	EmailVerified *bool                             `json:"emailVerified,omitempty"`
	Email         string                            `json:"email"`
	Nickname      *string                           `json:"nickname,omitempty"`
	PictureUrl    *string                           `json:"pictureUrl,omitempty"`
	Verified      *bool                             `json:"verified,omitempty"`
	UserLevel     *Level                            `json:"userLevel,omitempty"`
	Password      string                            `json:"password"`
	Friends       *UserCreateManyInput              `json:"friends,omitempty"`
	Todos         *TodoCreateManyWithoutAuthorInput `json:"todos,omitempty"`
}

type TodoCreateManyWithoutAuthorInput struct {
	Create  []TodoCreateWithoutAuthorInput `json:"create,omitempty"`
	Connect []TodoWhereUniqueInput         `json:"connect,omitempty"`
}

type TodoCreateWithoutAuthorInput struct {
	ID        *string                            `json:"id,omitempty"`
	Sort      *TodoSortCreateOneWithoutTodoInput `json:"sort,omitempty"`
	Content   string                             `json:"content"`
	Completed *bool                              `json:"completed,omitempty"`
	Deleted   *bool                              `json:"deleted,omitempty"`
	Private   *bool                              `json:"private,omitempty"`
	Locked    *bool                              `json:"locked,omitempty"`
}

type TodoUpdateInput struct {
	Sort      *TodoSortUpdateOneWithoutTodoInput      `json:"sort,omitempty"`
	Content   *string                                 `json:"content,omitempty"`
	Completed *bool                                   `json:"completed,omitempty"`
	Deleted   *bool                                   `json:"deleted,omitempty"`
	Author    *UserUpdateOneRequiredWithoutTodosInput `json:"author,omitempty"`
	Private   *bool                                   `json:"private,omitempty"`
	Locked    *bool                                   `json:"locked,omitempty"`
}

type TodoSortUpdateOneWithoutTodoInput struct {
	Create     *TodoSortCreateWithoutTodoInput     `json:"create,omitempty"`
	Update     *TodoSortUpdateWithoutTodoDataInput `json:"update,omitempty"`
	Upsert     *TodoSortUpsertWithoutTodoInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *TodoSortWhereUniqueInput           `json:"connect,omitempty"`
}

type TodoSortUpdateWithoutTodoDataInput struct {
	Userful *bool `json:"userful,omitempty"`
}

type TodoSortUpsertWithoutTodoInput struct {
	Update TodoSortUpdateWithoutTodoDataInput `json:"update"`
	Create TodoSortCreateWithoutTodoInput     `json:"create"`
}

type UserUpdateOneRequiredWithoutTodosInput struct {
	Create  *UserCreateWithoutTodosInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutTodosDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutTodosInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserUpdateWithoutTodosDataInput struct {
	Username      *string              `json:"username,omitempty"`
	EmailVerified *bool                `json:"emailVerified,omitempty"`
	Email         *string              `json:"email,omitempty"`
	Nickname      *string              `json:"nickname,omitempty"`
	PictureUrl    *string              `json:"pictureUrl,omitempty"`
	Verified      *bool                `json:"verified,omitempty"`
	UserLevel     *Level               `json:"userLevel,omitempty"`
	Password      *string              `json:"password,omitempty"`
	Friends       *UserUpdateManyInput `json:"friends,omitempty"`
}

type UserUpdateManyInput struct {
	Create     []UserCreateInput                      `json:"create,omitempty"`
	Update     []UserUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []UserWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []UserScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueNestedInput struct {
	Where UserWhereUniqueInput `json:"where"`
	Data  UserUpdateDataInput  `json:"data"`
}

type UserUpdateDataInput struct {
	Username      *string                           `json:"username,omitempty"`
	EmailVerified *bool                             `json:"emailVerified,omitempty"`
	Email         *string                           `json:"email,omitempty"`
	Nickname      *string                           `json:"nickname,omitempty"`
	PictureUrl    *string                           `json:"pictureUrl,omitempty"`
	Verified      *bool                             `json:"verified,omitempty"`
	UserLevel     *Level                            `json:"userLevel,omitempty"`
	Password      *string                           `json:"password,omitempty"`
	Friends       *UserUpdateManyInput              `json:"friends,omitempty"`
	Todos         *TodoUpdateManyWithoutAuthorInput `json:"todos,omitempty"`
}

type TodoUpdateManyWithoutAuthorInput struct {
	Create     []TodoCreateWithoutAuthorInput                `json:"create,omitempty"`
	Delete     []TodoWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []TodoWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []TodoWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []TodoWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []TodoUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
	Upsert     []TodoUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
	DeleteMany []TodoScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []TodoUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type TodoUpdateWithWhereUniqueWithoutAuthorInput struct {
	Where TodoWhereUniqueInput             `json:"where"`
	Data  TodoUpdateWithoutAuthorDataInput `json:"data"`
}

type TodoUpdateWithoutAuthorDataInput struct {
	Sort      *TodoSortUpdateOneWithoutTodoInput `json:"sort,omitempty"`
	Content   *string                            `json:"content,omitempty"`
	Completed *bool                              `json:"completed,omitempty"`
	Deleted   *bool                              `json:"deleted,omitempty"`
	Private   *bool                              `json:"private,omitempty"`
	Locked    *bool                              `json:"locked,omitempty"`
}

type TodoUpsertWithWhereUniqueWithoutAuthorInput struct {
	Where  TodoWhereUniqueInput             `json:"where"`
	Update TodoUpdateWithoutAuthorDataInput `json:"update"`
	Create TodoCreateWithoutAuthorInput     `json:"create"`
}

type TodoScalarWhereInput struct {
	ID                   *string                `json:"id,omitempty"`
	IDNot                *string                `json:"id_not,omitempty"`
	IDIn                 []string               `json:"id_in,omitempty"`
	IDNotIn              []string               `json:"id_not_in,omitempty"`
	IDLt                 *string                `json:"id_lt,omitempty"`
	IDLte                *string                `json:"id_lte,omitempty"`
	IDGt                 *string                `json:"id_gt,omitempty"`
	IDGte                *string                `json:"id_gte,omitempty"`
	IDContains           *string                `json:"id_contains,omitempty"`
	IDNotContains        *string                `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                `json:"id_not_ends_with,omitempty"`
	Content              *string                `json:"content,omitempty"`
	ContentNot           *string                `json:"content_not,omitempty"`
	ContentIn            []string               `json:"content_in,omitempty"`
	ContentNotIn         []string               `json:"content_not_in,omitempty"`
	ContentLt            *string                `json:"content_lt,omitempty"`
	ContentLte           *string                `json:"content_lte,omitempty"`
	ContentGt            *string                `json:"content_gt,omitempty"`
	ContentGte           *string                `json:"content_gte,omitempty"`
	ContentContains      *string                `json:"content_contains,omitempty"`
	ContentNotContains   *string                `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string                `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string                `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string                `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string                `json:"content_not_ends_with,omitempty"`
	Completed            *bool                  `json:"completed,omitempty"`
	CompletedNot         *bool                  `json:"completed_not,omitempty"`
	Deleted              *bool                  `json:"deleted,omitempty"`
	DeletedNot           *bool                  `json:"deleted_not,omitempty"`
	Private              *bool                  `json:"private,omitempty"`
	PrivateNot           *bool                  `json:"private_not,omitempty"`
	Locked               *bool                  `json:"locked,omitempty"`
	LockedNot            *bool                  `json:"locked_not,omitempty"`
	And                  []TodoScalarWhereInput `json:"AND,omitempty"`
	Or                   []TodoScalarWhereInput `json:"OR,omitempty"`
	Not                  []TodoScalarWhereInput `json:"NOT,omitempty"`
}

type TodoUpdateManyWithWhereNestedInput struct {
	Where TodoScalarWhereInput    `json:"where"`
	Data  TodoUpdateManyDataInput `json:"data"`
}

type TodoUpdateManyDataInput struct {
	Content   *string `json:"content,omitempty"`
	Completed *bool   `json:"completed,omitempty"`
	Deleted   *bool   `json:"deleted,omitempty"`
	Private   *bool   `json:"private,omitempty"`
	Locked    *bool   `json:"locked,omitempty"`
}

type UserUpsertWithWhereUniqueNestedInput struct {
	Where  UserWhereUniqueInput `json:"where"`
	Update UserUpdateDataInput  `json:"update"`
	Create UserCreateInput      `json:"create"`
}

type UserScalarWhereInput struct {
	ID                      *string                `json:"id,omitempty"`
	IDNot                   *string                `json:"id_not,omitempty"`
	IDIn                    []string               `json:"id_in,omitempty"`
	IDNotIn                 []string               `json:"id_not_in,omitempty"`
	IDLt                    *string                `json:"id_lt,omitempty"`
	IDLte                   *string                `json:"id_lte,omitempty"`
	IDGt                    *string                `json:"id_gt,omitempty"`
	IDGte                   *string                `json:"id_gte,omitempty"`
	IDContains              *string                `json:"id_contains,omitempty"`
	IDNotContains           *string                `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                `json:"id_not_ends_with,omitempty"`
	Username                *string                `json:"username,omitempty"`
	UsernameNot             *string                `json:"username_not,omitempty"`
	UsernameIn              []string               `json:"username_in,omitempty"`
	UsernameNotIn           []string               `json:"username_not_in,omitempty"`
	UsernameLt              *string                `json:"username_lt,omitempty"`
	UsernameLte             *string                `json:"username_lte,omitempty"`
	UsernameGt              *string                `json:"username_gt,omitempty"`
	UsernameGte             *string                `json:"username_gte,omitempty"`
	UsernameContains        *string                `json:"username_contains,omitempty"`
	UsernameNotContains     *string                `json:"username_not_contains,omitempty"`
	UsernameStartsWith      *string                `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith   *string                `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith        *string                `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith     *string                `json:"username_not_ends_with,omitempty"`
	EmailVerified           *bool                  `json:"emailVerified,omitempty"`
	EmailVerifiedNot        *bool                  `json:"emailVerified_not,omitempty"`
	Email                   *string                `json:"email,omitempty"`
	EmailNot                *string                `json:"email_not,omitempty"`
	EmailIn                 []string               `json:"email_in,omitempty"`
	EmailNotIn              []string               `json:"email_not_in,omitempty"`
	EmailLt                 *string                `json:"email_lt,omitempty"`
	EmailLte                *string                `json:"email_lte,omitempty"`
	EmailGt                 *string                `json:"email_gt,omitempty"`
	EmailGte                *string                `json:"email_gte,omitempty"`
	EmailContains           *string                `json:"email_contains,omitempty"`
	EmailNotContains        *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith         *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith      *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith           *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith        *string                `json:"email_not_ends_with,omitempty"`
	Nickname                *string                `json:"nickname,omitempty"`
	NicknameNot             *string                `json:"nickname_not,omitempty"`
	NicknameIn              []string               `json:"nickname_in,omitempty"`
	NicknameNotIn           []string               `json:"nickname_not_in,omitempty"`
	NicknameLt              *string                `json:"nickname_lt,omitempty"`
	NicknameLte             *string                `json:"nickname_lte,omitempty"`
	NicknameGt              *string                `json:"nickname_gt,omitempty"`
	NicknameGte             *string                `json:"nickname_gte,omitempty"`
	NicknameContains        *string                `json:"nickname_contains,omitempty"`
	NicknameNotContains     *string                `json:"nickname_not_contains,omitempty"`
	NicknameStartsWith      *string                `json:"nickname_starts_with,omitempty"`
	NicknameNotStartsWith   *string                `json:"nickname_not_starts_with,omitempty"`
	NicknameEndsWith        *string                `json:"nickname_ends_with,omitempty"`
	NicknameNotEndsWith     *string                `json:"nickname_not_ends_with,omitempty"`
	PictureUrl              *string                `json:"pictureUrl,omitempty"`
	PictureUrlNot           *string                `json:"pictureUrl_not,omitempty"`
	PictureUrlIn            []string               `json:"pictureUrl_in,omitempty"`
	PictureUrlNotIn         []string               `json:"pictureUrl_not_in,omitempty"`
	PictureUrlLt            *string                `json:"pictureUrl_lt,omitempty"`
	PictureUrlLte           *string                `json:"pictureUrl_lte,omitempty"`
	PictureUrlGt            *string                `json:"pictureUrl_gt,omitempty"`
	PictureUrlGte           *string                `json:"pictureUrl_gte,omitempty"`
	PictureUrlContains      *string                `json:"pictureUrl_contains,omitempty"`
	PictureUrlNotContains   *string                `json:"pictureUrl_not_contains,omitempty"`
	PictureUrlStartsWith    *string                `json:"pictureUrl_starts_with,omitempty"`
	PictureUrlNotStartsWith *string                `json:"pictureUrl_not_starts_with,omitempty"`
	PictureUrlEndsWith      *string                `json:"pictureUrl_ends_with,omitempty"`
	PictureUrlNotEndsWith   *string                `json:"pictureUrl_not_ends_with,omitempty"`
	Verified                *bool                  `json:"verified,omitempty"`
	VerifiedNot             *bool                  `json:"verified_not,omitempty"`
	UserLevel               *Level                 `json:"userLevel,omitempty"`
	UserLevelNot            *Level                 `json:"userLevel_not,omitempty"`
	UserLevelIn             []Level                `json:"userLevel_in,omitempty"`
	UserLevelNotIn          []Level                `json:"userLevel_not_in,omitempty"`
	Password                *string                `json:"password,omitempty"`
	PasswordNot             *string                `json:"password_not,omitempty"`
	PasswordIn              []string               `json:"password_in,omitempty"`
	PasswordNotIn           []string               `json:"password_not_in,omitempty"`
	PasswordLt              *string                `json:"password_lt,omitempty"`
	PasswordLte             *string                `json:"password_lte,omitempty"`
	PasswordGt              *string                `json:"password_gt,omitempty"`
	PasswordGte             *string                `json:"password_gte,omitempty"`
	PasswordContains        *string                `json:"password_contains,omitempty"`
	PasswordNotContains     *string                `json:"password_not_contains,omitempty"`
	PasswordStartsWith      *string                `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith   *string                `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith        *string                `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith     *string                `json:"password_not_ends_with,omitempty"`
	And                     []UserScalarWhereInput `json:"AND,omitempty"`
	Or                      []UserScalarWhereInput `json:"OR,omitempty"`
	Not                     []UserScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyWithWhereNestedInput struct {
	Where UserScalarWhereInput    `json:"where"`
	Data  UserUpdateManyDataInput `json:"data"`
}

type UserUpdateManyDataInput struct {
	Username      *string `json:"username,omitempty"`
	EmailVerified *bool   `json:"emailVerified,omitempty"`
	Email         *string `json:"email,omitempty"`
	Nickname      *string `json:"nickname,omitempty"`
	PictureUrl    *string `json:"pictureUrl,omitempty"`
	Verified      *bool   `json:"verified,omitempty"`
	UserLevel     *Level  `json:"userLevel,omitempty"`
	Password      *string `json:"password,omitempty"`
}

type UserUpsertWithoutTodosInput struct {
	Update UserUpdateWithoutTodosDataInput `json:"update"`
	Create UserCreateWithoutTodosInput     `json:"create"`
}

type TodoUpdateManyMutationInput struct {
	Content   *string `json:"content,omitempty"`
	Completed *bool   `json:"completed,omitempty"`
	Deleted   *bool   `json:"deleted,omitempty"`
	Private   *bool   `json:"private,omitempty"`
	Locked    *bool   `json:"locked,omitempty"`
}

type TodoSortCreateInput struct {
	Todo    *TodoCreateOneWithoutSortInput `json:"todo,omitempty"`
	Userful *bool                          `json:"userful,omitempty"`
}

type TodoCreateOneWithoutSortInput struct {
	Create  *TodoCreateWithoutSortInput `json:"create,omitempty"`
	Connect *TodoWhereUniqueInput       `json:"connect,omitempty"`
}

type TodoCreateWithoutSortInput struct {
	ID        *string                        `json:"id,omitempty"`
	Content   string                         `json:"content"`
	Completed *bool                          `json:"completed,omitempty"`
	Deleted   *bool                          `json:"deleted,omitempty"`
	Author    UserCreateOneWithoutTodosInput `json:"author"`
	Private   *bool                          `json:"private,omitempty"`
	Locked    *bool                          `json:"locked,omitempty"`
}

type TodoSortUpdateInput struct {
	Todo    *TodoUpdateOneWithoutSortInput `json:"todo,omitempty"`
	Userful *bool                          `json:"userful,omitempty"`
}

type TodoUpdateOneWithoutSortInput struct {
	Create     *TodoCreateWithoutSortInput     `json:"create,omitempty"`
	Update     *TodoUpdateWithoutSortDataInput `json:"update,omitempty"`
	Upsert     *TodoUpsertWithoutSortInput     `json:"upsert,omitempty"`
	Delete     *bool                           `json:"delete,omitempty"`
	Disconnect *bool                           `json:"disconnect,omitempty"`
	Connect    *TodoWhereUniqueInput           `json:"connect,omitempty"`
}

type TodoUpdateWithoutSortDataInput struct {
	Content   *string                                 `json:"content,omitempty"`
	Completed *bool                                   `json:"completed,omitempty"`
	Deleted   *bool                                   `json:"deleted,omitempty"`
	Author    *UserUpdateOneRequiredWithoutTodosInput `json:"author,omitempty"`
	Private   *bool                                   `json:"private,omitempty"`
	Locked    *bool                                   `json:"locked,omitempty"`
}

type TodoUpsertWithoutSortInput struct {
	Update TodoUpdateWithoutSortDataInput `json:"update"`
	Create TodoCreateWithoutSortInput     `json:"create"`
}

type TodoSortUpdateManyMutationInput struct {
	Userful *bool `json:"userful,omitempty"`
}

type UserUpdateInput struct {
	Username      *string                           `json:"username,omitempty"`
	EmailVerified *bool                             `json:"emailVerified,omitempty"`
	Email         *string                           `json:"email,omitempty"`
	Nickname      *string                           `json:"nickname,omitempty"`
	PictureUrl    *string                           `json:"pictureUrl,omitempty"`
	Verified      *bool                             `json:"verified,omitempty"`
	UserLevel     *Level                            `json:"userLevel,omitempty"`
	Password      *string                           `json:"password,omitempty"`
	Friends       *UserUpdateManyInput              `json:"friends,omitempty"`
	Todos         *TodoUpdateManyWithoutAuthorInput `json:"todos,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Username      *string `json:"username,omitempty"`
	EmailVerified *bool   `json:"emailVerified,omitempty"`
	Email         *string `json:"email,omitempty"`
	Nickname      *string `json:"nickname,omitempty"`
	PictureUrl    *string `json:"pictureUrl,omitempty"`
	Verified      *bool   `json:"verified,omitempty"`
	UserLevel     *Level  `json:"userLevel,omitempty"`
	Password      *string `json:"password,omitempty"`
}

type EmailTokenCreateInput struct {
	ID    *string `json:"id,omitempty"`
	Email string  `json:"email"`
	Token string  `json:"token"`
}

type EmailTokenUpdateInput struct {
	Email *string `json:"email,omitempty"`
	Token *string `json:"token,omitempty"`
}

type EmailTokenUpdateManyMutationInput struct {
	Email *string `json:"email,omitempty"`
	Token *string `json:"token,omitempty"`
}

type SessionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *SessionWhereInput              `json:"node,omitempty"`
	And                        []SessionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SessionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SessionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TodoSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *TodoWhereInput              `json:"node,omitempty"`
	And                        []TodoSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TodoSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TodoSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TodoSortSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *TodoSortWhereInput              `json:"node,omitempty"`
	And                        []TodoSortSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TodoSortSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TodoSortSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EmailTokenSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *EmailTokenWhereInput              `json:"node,omitempty"`
	And                        []EmailTokenSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EmailTokenSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EmailTokenSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SessionExec struct {
	exec *prisma.Exec
}

func (instance SessionExec) Exec(ctx context.Context) (*Session, error) {
	var v Session
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionExecArray) Exec(ctx context.Context) ([]Session, error) {
	var v []Session
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionFields = []string{"id", "username", "token", "updatedAt"}

type Session struct {
	ID        string `json:"id"`
	Username  string `json:"username"`
	Token     string `json:"token"`
	UpdatedAt string `json:"updatedAt"`
}

type SessionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SessionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SessionConnectionExec) Edges() *SessionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "SessionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Session"},
		"node",
		SessionFields)

	return &SessionEdgeExecArray{nodes}
}

func (instance *SessionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSession"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SessionConnectionExec) Exec(ctx context.Context) (*SessionConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &SessionConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance SessionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionConnectionExecArray) Exec(ctx context.Context) ([]SessionConnection, error) {
	var v []SessionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionConnectionFields = []string{}

type SessionConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []SessionEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type SessionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SessionEdgeExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

func (instance SessionEdgeExec) Exec(ctx context.Context) (*SessionEdge, error) {
	var v SessionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SessionEdgeExecArray) Exec(ctx context.Context) ([]SessionEdge, error) {
	var v []SessionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionEdgeFields = []string{"cursor"}

type SessionEdge struct {
	Node   Session `json:"node"`
	Cursor string  `json:"cursor"`
}

type TodoExec struct {
	exec *prisma.Exec
}

func (instance *TodoExec) Sort() *TodoSortExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TodoSort"},
		"sort",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

func (instance *TodoExec) Author() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"author",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

func (instance TodoExec) Exec(ctx context.Context) (*Todo, error) {
	var v Todo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoExecArray struct {
	exec *prisma.Exec
}

func (instance TodoExecArray) Exec(ctx context.Context) ([]Todo, error) {
	var v []Todo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoFields = []string{"id", "content", "completed", "deleted", "private", "locked"}

type Todo struct {
	ID        string `json:"id"`
	Content   string `json:"content"`
	Completed bool   `json:"completed"`
	Deleted   bool   `json:"deleted"`
	Private   bool   `json:"private"`
	Locked    bool   `json:"locked"`
}

type TodoSortExec struct {
	exec *prisma.Exec
}

func (instance *TodoSortExec) Todo() *TodoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Todo"},
		"todo",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

func (instance TodoSortExec) Exec(ctx context.Context) (*TodoSort, error) {
	var v TodoSort
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoSortExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSortExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSortExecArray) Exec(ctx context.Context) ([]TodoSort, error) {
	var v []TodoSort
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSortFields = []string{"sortID", "userful"}

type TodoSort struct {
	SortId  int32 `json:"sortID"`
	Userful *bool `json:"userful,omitempty"`
}

type UserExec struct {
	exec *prisma.Exec
}

type FriendsParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Friends(params *FriendsParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"friends",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExecArray{ret}
}

type TodosParamsExec struct {
	Where   *TodoWhereInput
	OrderBy *TodoOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Todos(params *TodosParamsExec) *TodoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TodoWhereInput", "TodoOrderByInput", "Todo"},
		"todos",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"}

type User struct {
	ID            string  `json:"id"`
	Username      string  `json:"username"`
	EmailVerified bool    `json:"emailVerified"`
	Email         string  `json:"email"`
	Nickname      *string `json:"nickname,omitempty"`
	PictureUrl    string  `json:"pictureUrl"`
	Verified      bool    `json:"verified"`
	UserLevel     Level   `json:"userLevel"`
	Password      string  `json:"password"`
}

type TodoConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TodoConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TodoConnectionExec) Edges() *TodoEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TodoWhereInput", "TodoOrderByInput", "TodoEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Todo"},
		"node",
		TodoFields)

	return &TodoEdgeExecArray{nodes}
}

func (instance *TodoConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTodo"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TodoConnectionExec) Exec(ctx context.Context) (*TodoConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &TodoConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance TodoConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TodoConnectionExecArray) Exec(ctx context.Context) ([]TodoConnection, error) {
	var v []TodoConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoConnectionFields = []string{}

type TodoConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []TodoEdge `json:"edges"`
}

type TodoEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TodoEdgeExec) Node() *TodoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Todo"},
		"node",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

func (instance TodoEdgeExec) Exec(ctx context.Context) (*TodoEdge, error) {
	var v TodoEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TodoEdgeExecArray) Exec(ctx context.Context) ([]TodoEdge, error) {
	var v []TodoEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoEdgeFields = []string{"cursor"}

type TodoEdge struct {
	Node   Todo   `json:"node"`
	Cursor string `json:"cursor"`
}

type TodoSortConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TodoSortConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TodoSortConnectionExec) Edges() *TodoSortEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TodoSortWhereInput", "TodoSortOrderByInput", "TodoSortEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "TodoSort"},
		"node",
		TodoSortFields)

	return &TodoSortEdgeExecArray{nodes}
}

func (instance *TodoSortConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTodoSort"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TodoSortConnectionExec) Exec(ctx context.Context) (*TodoSortConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &TodoSortConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance TodoSortConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSortConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSortConnectionExecArray) Exec(ctx context.Context) ([]TodoSortConnection, error) {
	var v []TodoSortConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSortConnectionFields = []string{}

type TodoSortConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []TodoSortEdge `json:"edges"`
}

type TodoSortEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TodoSortEdgeExec) Node() *TodoSortExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TodoSort"},
		"node",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

func (instance TodoSortEdgeExec) Exec(ctx context.Context) (*TodoSortEdge, error) {
	var v TodoSortEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoSortEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSortEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSortEdgeExecArray) Exec(ctx context.Context) ([]TodoSortEdge, error) {
	var v []TodoSortEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSortEdgeFields = []string{"cursor"}

type TodoSortEdge struct {
	Node   TodoSort `json:"node"`
	Cursor string   `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type EmailTokenExec struct {
	exec *prisma.Exec
}

func (instance EmailTokenExec) Exec(ctx context.Context) (*EmailToken, error) {
	var v EmailToken
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTokenExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTokenExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTokenExecArray) Exec(ctx context.Context) ([]EmailToken, error) {
	var v []EmailToken
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var emailTokenFields = []string{"id", "email", "token"}

type EmailToken struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Token string `json:"token"`
}

type EmailTokenConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EmailTokenConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EmailTokenConnectionExec) Edges() *emailTokenEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"emailTokenWhereInput", "emailTokenOrderByInput", "emailTokenEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "emailToken"},
		"node",
		emailTokenFields)

	return &emailTokenEdgeExecArray{nodes}
}

func (instance *EmailTokenConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateemailToken"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EmailTokenConnectionExec) Exec(ctx context.Context) (*EmailTokenConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &EmailTokenConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance EmailTokenConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTokenConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTokenConnectionExecArray) Exec(ctx context.Context) ([]EmailTokenConnection, error) {
	var v []EmailTokenConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var emailTokenConnectionFields = []string{}

type EmailTokenConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []EmailTokenEdge `json:"edges"`
}

type EmailTokenEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EmailTokenEdgeExec) Node() *EmailTokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "emailToken"},
		"node",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

func (instance EmailTokenEdgeExec) Exec(ctx context.Context) (*EmailTokenEdge, error) {
	var v EmailTokenEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTokenEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTokenEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTokenEdgeExecArray) Exec(ctx context.Context) ([]EmailTokenEdge, error) {
	var v []EmailTokenEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var emailTokenEdgeFields = []string{"cursor"}

type EmailTokenEdge struct {
	Node   EmailToken `json:"node"`
	Cursor string     `json:"cursor"`
}

type SessionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SessionSubscriptionPayloadExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionExec{ret}
}

func (instance *SessionSubscriptionPayloadExec) PreviousValues() *SessionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SessionPreviousValues"},
		"previousValues",
		[]string{"id", "username", "token", "updatedAt"})

	return &SessionPreviousValuesExec{ret}
}

func (instance SessionSubscriptionPayloadExec) Exec(ctx context.Context) (*SessionSubscriptionPayload, error) {
	var v SessionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SessionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SessionSubscriptionPayload, error) {
	var v []SessionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type SessionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Session     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SessionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExec) Exec(ctx context.Context) (*SessionPreviousValues, error) {
	var v SessionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExecArray) Exec(ctx context.Context) ([]SessionPreviousValues, error) {
	var v []SessionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionPreviousValuesFields = []string{"id", "username", "token", "updatedAt"}

type SessionPreviousValues struct {
	ID        string `json:"id"`
	Username  string `json:"username"`
	Token     string `json:"token"`
	UpdatedAt string `json:"updatedAt"`
}

type TodoSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TodoSubscriptionPayloadExec) Node() *TodoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Todo"},
		"node",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoExec{ret}
}

func (instance *TodoSubscriptionPayloadExec) PreviousValues() *TodoPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TodoPreviousValues"},
		"previousValues",
		[]string{"id", "content", "completed", "deleted", "private", "locked"})

	return &TodoPreviousValuesExec{ret}
}

func (instance TodoSubscriptionPayloadExec) Exec(ctx context.Context) (*TodoSubscriptionPayload, error) {
	var v TodoSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TodoSubscriptionPayload, error) {
	var v []TodoSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type TodoSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Todo        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TodoPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TodoPreviousValuesExec) Exec(ctx context.Context) (*TodoPreviousValues, error) {
	var v TodoPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TodoPreviousValuesExecArray) Exec(ctx context.Context) ([]TodoPreviousValues, error) {
	var v []TodoPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoPreviousValuesFields = []string{"id", "content", "completed", "deleted", "private", "locked"}

type TodoPreviousValues struct {
	ID        string `json:"id"`
	Content   string `json:"content"`
	Completed bool   `json:"completed"`
	Deleted   bool   `json:"deleted"`
	Private   bool   `json:"private"`
	Locked    bool   `json:"locked"`
}

type TodoSortSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TodoSortSubscriptionPayloadExec) Node() *TodoSortExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TodoSort"},
		"node",
		[]string{"sortID", "userful"})

	return &TodoSortExec{ret}
}

func (instance *TodoSortSubscriptionPayloadExec) PreviousValues() *TodoSortPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TodoSortPreviousValues"},
		"previousValues",
		[]string{"sortID", "userful"})

	return &TodoSortPreviousValuesExec{ret}
}

func (instance TodoSortSubscriptionPayloadExec) Exec(ctx context.Context) (*TodoSortSubscriptionPayload, error) {
	var v TodoSortSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoSortSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSortSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSortSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TodoSortSubscriptionPayload, error) {
	var v []TodoSortSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSortSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type TodoSortSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *TodoSort    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TodoSortPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TodoSortPreviousValuesExec) Exec(ctx context.Context) (*TodoSortPreviousValues, error) {
	var v TodoSortPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TodoSortPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TodoSortPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TodoSortPreviousValuesExecArray) Exec(ctx context.Context) ([]TodoSortPreviousValues, error) {
	var v []TodoSortPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TodoSortPreviousValuesFields = []string{"sortID", "userful"}

type TodoSortPreviousValues struct {
	SortId  int32 `json:"sortID"`
	Userful *bool `json:"userful,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "username", "emailVerified", "email", "nickname", "pictureUrl", "verified", "userLevel", "password"}

type UserPreviousValues struct {
	ID            string  `json:"id"`
	Username      string  `json:"username"`
	EmailVerified bool    `json:"emailVerified"`
	Email         string  `json:"email"`
	Nickname      *string `json:"nickname,omitempty"`
	PictureUrl    string  `json:"pictureUrl"`
	Verified      bool    `json:"verified"`
	UserLevel     Level   `json:"userLevel"`
	Password      string  `json:"password"`
}

type EmailTokenSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EmailTokenSubscriptionPayloadExec) Node() *EmailTokenExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "emailToken"},
		"node",
		[]string{"id", "email", "token"})

	return &EmailTokenExec{ret}
}

func (instance *EmailTokenSubscriptionPayloadExec) PreviousValues() *EmailTokenPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "emailTokenPreviousValues"},
		"previousValues",
		[]string{"id", "email", "token"})

	return &EmailTokenPreviousValuesExec{ret}
}

func (instance EmailTokenSubscriptionPayloadExec) Exec(ctx context.Context) (*EmailTokenSubscriptionPayload, error) {
	var v EmailTokenSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTokenSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTokenSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTokenSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EmailTokenSubscriptionPayload, error) {
	var v []EmailTokenSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var emailTokenSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type EmailTokenSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *EmailToken  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EmailTokenPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EmailTokenPreviousValuesExec) Exec(ctx context.Context) (*EmailTokenPreviousValues, error) {
	var v EmailTokenPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailTokenPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailTokenPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EmailTokenPreviousValuesExecArray) Exec(ctx context.Context) ([]EmailTokenPreviousValues, error) {
	var v []EmailTokenPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var emailTokenPreviousValuesFields = []string{"id", "email", "token"}

type EmailTokenPreviousValues struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Token string `json:"token"`
}
